/* Copyright 2017 JP Norair
  *
  * Licensed under the OpenTag License, Version 1.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.indigresso.com/wiki/doku.php?id=opentag:license_1_0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  */
/**
  * @file       /apps/_common/fs_default_startup.c
  * @author     JP Norair
  * @version    R102
  * @date       9 May 2017
  * @brief      Startup Data for default filesystem
  *
  * Usually this file is included into app/main.c rather than compiled.  If you 
  * try to compile it and also include it, you will get linker errors as the
  * linker has two of each symbol.  So, just do like below:
  *
  * #include <../_common/fs_default_startup.c>
  * 
  ******************************************************************************
  */

#ifndef __DEFAULT_FS_STARTUP_C
#define __DEFAULT_FS_STARTUP_C

#include <otstd.h>
#include <board.h>

/// Constant "_ERS" is the value of an erased byte in nonvolatile memory.
/// Usually it is FF or 00, depending on the way the Flash memory is designed.
#ifndef _ERS
#   if defined(__STM32L__)
#       define _ERS 0x00
#   else
#       define _ERS 0xFF
#   endif
#endif

/// The OpenTag startup routine will place IDs generated by programmatic means
/// in this empty space.
#define __VID   _ERS, _ERS
#define __UID   _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS


/// Rough Board Frequency setup
#ifndef RF_PARAM_BAND
#   define RF_PARAM_BAND    433
#endif
#if (RF_PARAM_BAND == 433)
#   define _BAND_ID 0
#elif (RF_PARAM_BAND >= 860) && (RF_PARAM_BAND < 870)
#   define _BAND_ID 1
#elif (RF_PARAM_BAND >= 900) && (RF_PARAM_BAND < 925)
#   define _BAND_ID 2
#else
#   warning "RF_PARAM_BAND not defined to a known band, defaulting to 433 MHz"
#   define _BAND_ID 0
#endif


/** Default File data allocations
  * ============================================================================
  * - Veelite also uses an additional 1536 bytes for wear leveling
  * - Wear leveling overhead is configurable, but fixed for all FS sizes
  * - Veelite virtual addressing allocations of key sectors below:
  *     Overhead:   0000 to 03FF        (1024 bytes alloc)
  *     ISFSB:      0400 to 049F        (160 bytes alloc)
  *     GFB:        04A0 to 089F        (1024 bytes)
  *     ISFB:       08A0 to 0FFF        (1888 bytes)
  */
#define SPLIT_SHORT(VAL)    (ot_u8)((ot_u16)(VAL) >> 8), (ot_u8)((ot_u16)(VAL) & 0x00FF)
#define SPLIT_LONG(VAL)     (ot_u8)((ot_u32)(VAL) >> 24), (ot_u8)(((ot_u32)(VAL) >> 16) & 0xFF), \
                            (ot_u8)(((ot_u32)(VAL) >> 8) & 0xFF), (ot_u8)((ot_u32)(VAL) & 0xFF)

#define SPLIT_SHORT_LE(VAL) (ot_u8)((ot_u16)(VAL) & 0x00FF), (ot_u8)((ot_u16)(VAL) >> 8)
#define SPLIT_LONG_LE(VAL)  (ot_u8)((ot_u32)(VAL) & 0xFF), (ot_u8)(((ot_u32)(VAL) >> 8) & 0xFF), \
                            (ot_u8)(((ot_u32)(VAL) >> 16) & 0xFF), (ot_u8)((ot_u32)(VAL) >> 24)


/// These overhead are the Veelite vl_header files. They are hard coded,
/// and they must be in the endian of the platform. (Little endian here)

#if (CC_SUPPORT == GCC)
const ot_u8 overhead_files[] __attribute__ ((section(".vl_ov"))) = {
#elif (CC_SUPPORT == CL430)
#pragma DATA_SECTION(overhead_files, ".vl_ov")
const ot_u8 overhead_files[] = {
#endif
    //0x00, 0x00, 0x00, 0x01,                 /* GFB ELements 0 - 3 */
    //0x00, GFB_MOD_standard,
    //0x00, 0x14, 0xFF, 0xFF,
    //0x00, 0x00, 0x00, 0x01,
    //0x01, GFB_MOD_standard,
    //0x00, 0x15, 0xFF, 0xFF,
    //0x00, 0x00, 0x00, 0x01,
    //0x02, GFB_MOD_standard,
    //0x00, 0x16, 0xFF, 0xFF,
    //0x00, 0x00, 0x00, 0x01,
    //0x03, GFB_MOD_standard,
    //0x00, 0x17, 0xFF, 0xFF,

    ISFS_LEN(transit_data), 0x00,
    ISFS_ALLOC(transit_data), 0x00,
    ISFS_ID(transit_data),
    ISFS_MOD(transit_data),
    SPLIT_SHORT_LE(ISFS_BASE(transit_data)),
    _ERS, _ERS,

    ISFS_LEN(capability_data), 0x00,
    ISFS_ALLOC(capability_data), 0x00,
    ISFS_ID(capability_data),
    ISFS_MOD(capability_data),
    SPLIT_SHORT_LE(ISFS_BASE(capability_data)),
    _ERS, _ERS,

    ISFS_LEN(query_results), 0x00,
    ISFS_ALLOC(query_results), 0x00,
    ISFS_ID(query_results),
    ISFS_MOD(query_results),
    SPLIT_SHORT_LE(ISFS_BASE(query_results)),
    _ERS, _ERS,

    ISFS_LEN(hardware_fault), 0x00,
    ISFS_ALLOC(hardware_fault), 0x00,
    ISFS_ID(hardware_fault),
    ISFS_MOD(hardware_fault),
    SPLIT_SHORT_LE(ISFS_BASE(hardware_fault)),
    _ERS, _ERS,

    ISFS_LEN(device_discovery), 0x00,
    ISFS_ALLOC(device_discovery), 0x00,
    ISFS_ID(device_discovery),
    ISFS_MOD(device_discovery),
    SPLIT_SHORT_LE(ISFS_BASE(device_discovery)),
    _ERS, _ERS,

    ISFS_LEN(device_capability), 0x00,
    ISFS_ALLOC(device_capability), 0x00,
    ISFS_ID(device_capability),
    ISFS_MOD(device_capability),
    SPLIT_SHORT_LE(ISFS_BASE(device_capability)),
    _ERS, _ERS,

    ISFS_LEN(device_channel_utilization), 0x00,
    ISFS_ALLOC(device_channel_utilization), 0x00,
    ISFS_ID(device_channel_utilization),
    ISFS_MOD(device_channel_utilization),
    SPLIT_SHORT_LE(ISFS_BASE(device_channel_utilization)),
    _ERS, _ERS,

    ISFS_LEN(location_data), 0x00,
    ISFS_ALLOC(location_data), 0x00,
    ISFS_ID(location_data),
    ISFS_MOD(location_data),
    SPLIT_SHORT_LE(ISFS_BASE(location_data)),
    _ERS, _ERS,

    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    
    /* Mode 2 ISFs, written as little endian */
    ISF_LEN(network_settings), 0x00,                /* Length, little endian */
    SPLIT_SHORT_LE(ISF_ALLOC(network_settings)),    /* Alloc, little endian */
    ISF_ID(network_settings),                       /* ID */
    ISF_MOD(network_settings),                      /* Perms */
    SPLIT_SHORT_LE(ISF_BASE(network_settings)),
    SPLIT_SHORT_LE(ISF_MIRROR(network_settings)),

    ISF_LEN(device_features), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(device_features)),
    ISF_ID(device_features),
    ISF_MOD(device_features),
    SPLIT_SHORT_LE(ISF_BASE(device_features)),
    SPLIT_SHORT_LE(ISF_MIRROR(device_features)),

    ISF_LEN(channel_configuration), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(channel_configuration)),
    ISF_ID(channel_configuration),
    ISF_MOD(channel_configuration),
    SPLIT_SHORT_LE(ISF_BASE(channel_configuration)),
    SPLIT_SHORT_LE(ISF_MIRROR(channel_configuration)),

    ISF_LEN(real_time_scheduler), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(real_time_scheduler)),
    ISF_ID(real_time_scheduler),
    ISF_MOD(real_time_scheduler),
    SPLIT_SHORT_LE(ISF_BASE(real_time_scheduler)),
    SPLIT_SHORT_LE(ISF_MIRROR(real_time_scheduler)),

    ISF_LEN(hold_scan_sequence), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(hold_scan_sequence)),
    ISF_ID(hold_scan_sequence),
    ISF_MOD(hold_scan_sequence),
    SPLIT_SHORT_LE(ISF_BASE(hold_scan_sequence)),
    SPLIT_SHORT_LE(ISF_MIRROR(hold_scan_sequence)),

    ISF_LEN(sleep_scan_sequence), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(sleep_scan_sequence)),
    ISF_ID(sleep_scan_sequence),
    ISF_MOD(sleep_scan_sequence),
    SPLIT_SHORT_LE(ISF_BASE(sleep_scan_sequence)),
    SPLIT_SHORT_LE(ISF_MIRROR(sleep_scan_sequence)),

    ISF_LEN(beacon_transmit_sequence), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(beacon_transmit_sequence)),
    ISF_ID(beacon_transmit_sequence),
    ISF_MOD(beacon_transmit_sequence),
    SPLIT_SHORT_LE(ISF_BASE(beacon_transmit_sequence)),
    SPLIT_SHORT_LE(ISF_MIRROR(beacon_transmit_sequence)),

    ISF_LEN(isf_list), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(isf_list)),
    ISF_ID(isf_list),
    ISF_MOD(isf_list),
    SPLIT_SHORT_LE(ISF_BASE(isf_list)),
    SPLIT_SHORT_LE(ISF_MIRROR(isf_list)),

    ISF_LEN(isfs_list), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(isfs_list)),
    ISF_ID(isfs_list),
    ISF_MOD(isfs_list),
    SPLIT_SHORT_LE(ISF_BASE(isfs_list)),
    SPLIT_SHORT_LE(ISF_MIRROR(isfs_list)),

    ISF_LEN(gfb_file_list), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(gfb_file_list)),
    ISF_ID(gfb_file_list),
    ISF_MOD(gfb_file_list),
    SPLIT_SHORT_LE(ISF_BASE(gfb_file_list)),
    SPLIT_SHORT_LE(ISF_MIRROR(gfb_file_list)),

    ISF_LEN(location_data_list), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(location_data_list)),
    ISF_ID(location_data_list),
    ISF_MOD(location_data_list),
    SPLIT_SHORT_LE(ISF_BASE(location_data_list)),
    SPLIT_SHORT_LE(ISF_MIRROR(location_data_list)),

    ISF_LEN(ipv6_addresses), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(ipv6_addresses)),
    ISF_ID(ipv6_addresses),
    ISF_MOD(ipv6_addresses),
    SPLIT_SHORT_LE(ISF_BASE(ipv6_addresses)),
    SPLIT_SHORT_LE(ISF_MIRROR(ipv6_addresses)),

    ISF_LEN(sensor_list), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(sensor_list)),
    ISF_ID(sensor_list),
    ISF_MOD(sensor_list),
    SPLIT_SHORT_LE(ISF_BASE(sensor_list)),
    SPLIT_SHORT_LE(ISF_MIRROR(sensor_list)),

    ISF_LEN(sensor_alarms), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(sensor_alarms)),
    ISF_ID(sensor_alarms),
    ISF_MOD(sensor_alarms),
    SPLIT_SHORT_LE(ISF_BASE(sensor_alarms)),
    SPLIT_SHORT_LE(ISF_MIRROR(sensor_alarms)),

    ISF_LEN(root_authentication_key), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(root_authentication_key)),
    ISF_ID(root_authentication_key),
    ISF_MOD(root_authentication_key),
    SPLIT_SHORT_LE(ISF_BASE(root_authentication_key)),
    SPLIT_SHORT_LE(ISF_MIRROR(root_authentication_key)),

    ISF_LEN(user_authentication_key), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(user_authentication_key)),
    ISF_ID(user_authentication_key),
    ISF_MOD(user_authentication_key),
    SPLIT_SHORT_LE(ISF_BASE(user_authentication_key)),
    SPLIT_SHORT_LE(ISF_MIRROR(user_authentication_key)),

    ISF_LEN(routing_code), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(routing_code)),
    ISF_ID(routing_code),
    ISF_MOD(routing_code),
    SPLIT_SHORT_LE(ISF_BASE(routing_code)),
    SPLIT_SHORT_LE(ISF_MIRROR(routing_code)),

    ISF_LEN(user_id), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(user_id)),
    ISF_ID(user_id),
    ISF_MOD(user_id),
    SPLIT_SHORT_LE(ISF_BASE(user_id)),
    SPLIT_SHORT_LE(ISF_MIRROR(user_id)),

    ISF_LEN(optional_command_list), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(optional_command_list)),
    ISF_ID(optional_command_list),
    ISF_MOD(optional_command_list),
    SPLIT_SHORT_LE(ISF_BASE(optional_command_list)),
    SPLIT_SHORT_LE(ISF_MIRROR(optional_command_list)),

    ISF_LEN(memory_size), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(memory_size)),
    ISF_ID(memory_size),
    ISF_MOD(memory_size),
    SPLIT_SHORT_LE(ISF_BASE(memory_size)),
    SPLIT_SHORT_LE(ISF_MIRROR(memory_size)),

    ISF_LEN(table_query_size), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(table_query_size)),
    ISF_ID(table_query_size),
    ISF_MOD(table_query_size),
    SPLIT_SHORT_LE(ISF_BASE(table_query_size)),
    SPLIT_SHORT_LE(ISF_MIRROR(table_query_size)),

    ISF_LEN(table_query_results), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(table_query_results)),
    ISF_ID(table_query_results),
    ISF_MOD(table_query_results),
    SPLIT_SHORT_LE(ISF_BASE(table_query_results)),
    SPLIT_SHORT_LE(ISF_MIRROR(table_query_results)),

    ISF_LEN(hardware_fault_status), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(hardware_fault_status)),
    ISF_ID(hardware_fault_status),
    ISF_MOD(hardware_fault_status),
    SPLIT_SHORT_LE(ISF_BASE(hardware_fault_status)),
    SPLIT_SHORT_LE(ISF_MIRROR(hardware_fault_status)),

	ISF_LEN(gnss_output), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(gnss_output)),
    ISF_ID(gnss_output),
    ISF_MOD(gnss_output),
    SPLIT_SHORT_LE(ISF_BASE(gnss_output)),
    SPLIT_SHORT_LE(ISF_MIRROR(gnss_output)),
    
    ISF_LEN(agps_input), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(agps_input)),
    ISF_ID(agps_input),
    ISF_MOD(agps_input),
    SPLIT_SHORT_LE(ISF_BASE(agps_input)),
    SPLIT_SHORT_LE(ISF_MIRROR(agps_input)),

    ISF_LEN(application_extension), 0x00,
    SPLIT_SHORT_LE(ISF_ALLOC(application_extension)),
    ISF_ID(application_extension),
    ISF_MOD(application_extension),
    SPLIT_SHORT_LE(ISF_BASE(application_extension)),
    SPLIT_SHORT_LE(ISF_MIRROR(application_extension)),
};




/// This array contains stock codes for isfs.  They are ordered strings.
#if (CC_SUPPORT == GCC)
const ot_u8 isfs_stock_codes[] __attribute__((section(".vl_isfs"))) = {
#elif (CC_SUPPORT == CL430)
#pragma DATA_SECTION(isfs_stock_codes, ".vl_isfs")
const ot_u8 isfs_stock_codes[] = {
#endif
    0x10, 0x11, 0x18, _ERS,
    0x12, 0x13, 0x14, _ERS,
    0x15, _ERS,
    0x16, _ERS,
    0x00, 0x01,
    0x01, 0x06, 0x07, _ERS,
    0x02, 0x03, 0x04, 0x05,
    0x11, _ERS,
};


#if (GFB_TOTAL_BYTES > 0)
#if (CC_SUPPORT == GCC)
__attribute__((section(".vl_gfb")))
#elif (CC_SUPPORT == CL430)
#pragma DATA_SECTION(gfb_stock_files, ".vl_gfb")
#endif
const ot_u8 gfb_stock_files[] = {_ERS, _ERS};
#endif




/// Firmware & Version information for ISF1 (Device Features)
/// This will look something like "OTv1  xyyyyyyy" where x is a letter and
/// yyyyyyy is a Base64 string containing a 16 bit build-id and a 32 bit mask
/// indicating the features compiled-into the build.
#include <otsys/version.h>

#define BV0     (ot_u8)(OT_VERSION_MAJOR + 48)
#define BT0     (ot_u8)(OT_BUILDTYPE)
#define BC0     OT_BUILDCODE0
#define BC1     OT_BUILDCODE1
#define BC2     OT_BUILDCODE2
#define BC3     OT_BUILDCODE3
#define BC4     OT_BUILDCODE4
#define BC5     OT_BUILDCODE5
#define BC6     OT_BUILDCODE6
#define BC7     OT_BUILDCODE7

/// This array contains the stock ISF data.  ISF data must be big endian!
#if (CC_SUPPORT == GCC)
const ot_u8 isf_stock_files[] __attribute__((section(".vl_isf"))) = {
#elif (CC_SUPPORT == CL430)
#pragma DATA_SECTION(isf_stock_files, ".vl_isf")
const ot_u8 isf_stock_files[] = {
#endif
    /* network settings: id=0x00, len=10, alloc=10 */
    __VID,                                              /* VID */
    0x11,                                               /* Device Subnet */
    0x11,                                               /* Beacon Subnet */
    SPLIT_SHORT(OT_ACTIVE_SETTINGS),                    /* Active Setting */
    0x00,                                               /* Default Device Flags */
    1,                                                  /* Beacon Attempts */
    SPLIT_SHORT(2),                                     /* Hold Scan Sequence Cycles */

    /* device features: id=0x01, len=48, alloc=48 */
    __UID,                                              /* UID: 8 bytes*/
    SPLIT_SHORT(OT_SUPPORTED_SETTINGS),                 /* Supported Setting */
    M2_PARAM(MAXFRAME),                                 /* Max Frame Length */
    1,                                                  /* Max Frames per Packet */
    SPLIT_SHORT(0),                                     /* DLLS Methods */
    SPLIT_SHORT(0),                                     /* NLS Methods */
    SPLIT_SHORT(ISF_TOTAL_BYTES),                       /* ISFB Total Memory */
    SPLIT_SHORT(ISF_TOTAL_BYTES-ISF_HEAP_BYTES),        /* ISFB Available Memory */
    SPLIT_SHORT(ISFS_TOTAL_BYTES),                      /* ISFSB Total Memory */
    SPLIT_SHORT(ISFS_TOTAL_BYTES-ISFS_HEAP_BYTES),      /* ISFSB Available Memory */
    SPLIT_SHORT(GFB_TOTAL_BYTES),                       /* GFB Total Memory */
    SPLIT_SHORT(GFB_TOTAL_BYTES-GFB_HEAP_BYTES),        /* GFB Available Memory */
    SPLIT_SHORT(GFB_FILE_BYTES),                        /* GFB File Size */
    0,                                                  /* RFU */
    OT_PARAM(SESSION_DEPTH),                          /* Session Stack Depth */
    'O','T','v',BV0,' ',' ',
    BT0,BC0,BC1,BC2,BC3,BC4,BC5,BC6,BC7, 0,             /* Firmware & Version as C-string */

    /* channel configuration: id=0x02, len=24, alloc=48 */
    0x00, 0x00,                                         /* Header: 2 bytes RFU */
    _BAND_ID,                                           /* Header: Regulatory Code */
    0x00,                                               /* Header: TX Duty Cycle */
    0x00,                                               /* Header: TX Power Autoscaling Control */
    0x00,                                               /* Header: RFU */
    
    (0x00), 0x00,                                       /* Channel Spectrum ID & RFU */
    (ot_u8)(( (14) + 40 )*2),                            /* Channel TX Power Limit */
    (ot_u8)( 160 ),                                     /* Channel Link Quality Filter Level */
    (ot_u8)( (-130) + 140 ),                            /* CS RSSI Threshold */
    (ot_u8)( (-120) + 140 ),                            /* CCA RSSI Threshold*/

    (0x10), 0x00,                                       /* Channel Spectrum ID & RFU */
    (ot_u8)(( (14) + 40 )*2),                            /* Channel TX Power Limit (dBm) */
    (ot_u8)( 140 ),                                     /* Channel Link Quality Filter Level */
    (ot_u8)( (-120) + 140 ),                            /* CS RSSI Threshold */
    (ot_u8)( (-110) + 140 ),                            /* CCA RSSI Threshold*/

    (0x20), 0x00,                                       /* Channel Spectrum ID & RFU */
    (ot_u8)(( (14) + 40 )*2),                            /* Channel TX Power Limit (dBm) */
    (ot_u8)( 140 ),                                     /* Channel Link Quality Filter Level */
    (ot_u8)( (-120) + 140 ),                            /* CS RSSI Threshold */
    (ot_u8)( (-110) + 140 ),                            /* CCA RSSI Threshold*/

    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,


    /* real time scheduler: id=0x03, len=12, alloc=12 */
    0x00, 0x0F,                                         /* HSS Sync Mask */
    0x00, 0x08,                                         /* HSS Sync Value */
    0x00, 0x03,                                         /* SSS Sync Mask */
    0x00, 0x02,                                         /* SSS Sync Value */
    0x00, 0x03,                                         /* BTS Sync Mask */
    0x00, 0x02,                                         /* BTS Sync Value */

    /* hold scan periods: id=0x04, len=8, alloc=32 */
    /* Period data format in Section X.9.4.5 of Mode 2 spec */
    0x18, 0x31, 0x00, 0x00,                             /* Channel X scan, Scan Code, Next Scan ms */
    0x2B, 0x31, 0x00, 0x00,
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,

    /* sleep scan periods: id=0x05, len=4, alloc=32 */
    /* Period data format in Section X.9.4.5 of Mode 2 spec */
    0x18, 0x50, 0x00, 0x00,                             /* Channel X scan, Scan Code, Next Scan ms */
    _ERS, _ERS, _ERS, _ERS,                             /* NOTE: Scan Code should be less than     */
    _ERS, _ERS, _ERS, _ERS,                             /*       Next Scan, or else you will be    */
    _ERS, _ERS, _ERS, _ERS,                             /*       doing nothing except scanning!    */
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,

    /* beacon transmit periods: id=0x06, len=16, alloc=24 */
    /* Period data format in Section X.9.4.7 of Mode 2 spec */ //0x0240
    0x18, 0x02, 0x20, 0x00, 0x00, 0x08, 0x00, 0x80,     /* Channel X beacon, Beacon ISF File, Next Beacon ms */
    0x2B, 0x02, 0x20, 0x00, 0x00, 0x08, 0x10, 0x00,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,

    /* User ISF List: id=0x07, len=1, alloc=24 */
    0xFF, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,     /* List of Protocols supported (Tentative)*/
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,

    /* ISFS list: id=0x08, len=12, alloc=16 */
    0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x18,
    0x80, 0x81, 0x82, 0x83, _ERS, _ERS, _ERS, _ERS,

    /* GFB File List: id=0x09, len=0, alloc=8 */
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,

    /* Location Data List: id=0x0A, len=0, alloc=64 */
    /* Stored exclusively in Mirror */

    /* IPv6 Addresses: id=0x0B, len=0, alloc=48 */
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,

    /* Sensor List: id=0x0C, len=16, alloc=16 (just dummy values right now) */
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x00,

    /* Sensor Alarms: id=0x0D, len=2, alloc=2 (just dummy values right now) */
    0x00, 0x00,

    /* root auth key:       id=0x0E, not used in this build */
    /* Admin auth key:      id=0x0F, not used in this build */

    /* Routing Code: id=0x10, len=0, alloc=50 */
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS,

    /* User ID: id=0x11, len=0, alloc=60 */
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS, _ERS,
    _ERS, _ERS, _ERS, _ERS,

    /* Mode 1 Optional Command list: id=0x12, len=7, alloc=8 */
    0x13, 0x93, 0x0C, 0x0E, 0x60, 0xE0, 0x8E, 0xFF,

    /* Mode 1 Memory Size: id=0x13, len=12, alloc=12 */
    0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    /* Mode 1 Table Query Size: id=0x14, len=1, alloc=2 */
    0x00, 0xFF,

    /* Mode 1 Table Query Results: id=0x15, len=7, alloc=8 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,

    /* HW Fault Status: id=0x16, len=3, alloc=4 */
    0x00, 0x00, 0x00, 0xFF,

	/* GNSS Output id=0x17, len=0, alloc=? */
	/* Stored Exclusively in mirror */

	/* AGPS Input id=0x18, len=0, alloc=? */
	/* Stored Exclusively in mirror */

    /* Application Extension: id=0xFF, len=0, alloc=64 */
    /* Stored Exclusively in mirror */
};



//__attribute__((section(".vl_fallow")))
//const ot_u8 vl_fallow_space[ (FLASH_PAGE_SIZE*OTF_VWORM_FALLOW_PAGES) ];
#endif

